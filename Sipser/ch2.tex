\chapter{Context-Free Languages}

\begin{reference}{Defn}{cfg}
  (2.2) A \textbf{\textit{context-free grammar}} $G$ is a 4-tuple $(V,\Sigma,R,S)$, where
  \begin{enumerate}
    \item $V$ is a finite set called the \textbf{\textit{variables}},
    \item $\Sigma$ a finite set such that $\Sigma\cap V=\emptyset$ called \textbf{\textit{terminals}},
    \item $R$ a finite set of \textbf{\textit{rules}} where each rule is a funtion of the form $V\rightarrow (V\cup \Sigma)^*$ and
    \item $S\in V$ the start variable.
  \end{enumerate}
  For $u,v\in(V\cup\Sigma)^*$ write
  \begin{enumerate}
    \item $u\Rightarrow v$ (say that $u$ \textbf{\textit{yields}} $v$) if can go from $u$ to $v$ with one substitution step.
    \item $u\xRightarrow{*}v$ (say that $u$ \textbf{\textit{derives}} $v$) if can go from $u$ to $v$ with some number of substitions steps.
    \item $u_1\Rightarrow u_2\Rightarrow\cdots\Rightarrow u_k=v$ is called a \textbf{\textit{derivation}} of $v$ from $u$. If $u=S$ then ``from $u$'' can be omitted.
  \end{enumerate}
  $L(G)=\{w|(w\in \Sigma^*)\wedge (S\xRightarrow{*}v)\}$ is called a \textbf{\textit{context-free language}}.
\end{reference}

\textit{Context-free} means that we can apply substitutions regardless of the contexts.

\begin{reference}{Defn}{ambiguity}
  (2.7) A derivation of a string $w$ in a context-free grammar $G$ is a \textbf{\textit{leftmost derivation}} if at every step the leftmost remaining variable is the one replaced. $w$ is derived \textbf{\textit{ambiguously}} in $G$ if it has two or more different leftmost derivations. $G$ is \textbf{\textit{ambiguous}} if it generates some string ambiguously.
\end{reference}

Sometimes when we have an ambiguous grammar we can find an unambiguous grammar that generates the same language. Some context-free languages, however, can be generated only by ambiguous grammars. Such languages are called \textbf{\textit{inherently ambiguous}}.

\begin{reference}{Defn}{cnf}
  (2.8) A CFG is in \textbf{\textit{Chomsky normal form}} if every rule is of the form $A\to BC$ or $A\to a$, where $a$ is any terminal and $A,B$ and $C$ are any variables (except that $B$ and $C$ may not be the start variable). In addition permit $S\to \varepsilon$, where $S$ is the start variable.
\end{reference}

\begin{reference}{Thm}{cnfthm}
  (2.9) Any context-free language is generated by a context-free grammar in Chomsky normal form.
\end{reference}

\begin{proof}[Proof Idea]
  We basically convert an arbitrary CFG into Chomsky normal form. This is nontrivial and demands carefulness. For the proof see page 109.
\end{proof}

\begin{reference}{Defn}{pda}
  (2.13) A \textbf{\textit{pushdown automaton}} is a $6$-tuple $(Q,\Sigma,\Gamma,\delta,q_0,F)$, where $\Gamma$ is the stack alphabet and $\delta:Q\times \Sigma_{\varepsilon}\times \Gamma_{\varepsilon}\rightarrow \mathcal{P}(Q\times \Gamma_{\varepsilon})$ the transition function.
\end{reference}

Our PDA models is nondeterministic. The nondeterministic forks replicate the stack. Also, we can check if the stack is effectively empty by writing at the beginning a custom sign (say \$) at the bottom of it.

\begin{reference}{Lem}{cfl2pda}
  (2.21) If $A$ is a CFL then some PDA recognizes it.
\end{reference}

\begin{proof}[Proof Idea]
  PDA begins with starting variable and guesses substitutions. It keeps intermediate generated strings on stack. When done, compare with input. We can only substitute variables when on the top of stack. If a terminal is on the top of stack, pop it and compare with input.
\end{proof}

\begin{reference}{Lem}{pda2cfl}
  (2.27) If a PDA recognizes $A$ then it is a CFL.
\end{reference}

\begin{proof}[Proof]
  Say that $P=\{Q,\Sigma,\Gamma,\delta,q_0,\{q_{accept}\}\})$ and construct $G$. The variables of $G$ are $\{A_{p,q}|p,q\in Q\}$. The start variable is $A_{q_0,q_{accept}}$. The set of rules $R$ of $G$ is described as follows.
  \begin{enumerate}
    \item For each $p,q,r,s\in Q,u\in \Gamma$, and $a,b\in \Sigma_{\varepsilon}$, if $(r,u)\in\delta(p,a,\varepsilon)\wedge (q,\varepsilon)\in \delta(s,b,u), (A_{p,q}\rightarrow aA_{r,s}b)\in R.$
    \item For each $p,q,r\in Q, (A_{p,q}\rightarrow A_{p,r}A_{r,q})\in R.$
    \item For each $p\in Q, (A_{p,p}\rightarrow \varepsilon)\in R.$\qedhere
  \end{enumerate}
\end{proof}

\begin{reference}{Thm}{pumpingcfl}
  \textbf{Pumping Lemma for CFLs:} For every CFL $A$, there is a $p$ such that if $s\in A$ and $|s|\geq p$ then $s=uvxyz$ where
  \begin{enumerate}
    \item $uv^ixy^iz\in A$ for all $i\geq 0$
    \item $vy\neq \varepsilon$
    \item $|vxy|\leq p$\qedhere
  \end{enumerate}
\end{reference}

\begin{proof}[Proof Idea]
  Let $b$ be the length of the longest right hand side of a rule (the max branching of the parse tree). Let $h$ be the height of the parse tree for $s$. A tree of height $h$ and max branching $b$ has at most $b^h$ leaves, so $|s|\leq b^h$. Let $p=b^{|V|}+1$ where $|V|$ is the number of variables in the grammar. So if $|s|\geq p>b^{|V|}$ then $|s|>b^{|V|}$ and so $h>|V|$. Thus at least $|V|+1$ variables occur in the longest path. So some variable $R$ must repeat on a path. For item 1 we can cut and paste $R$ arbitrarily. For item 2 we add a requirement that the parse tree has to be smallest, meaning that $R$ to $R$ without generating new symbols is not allowed during the construction of the parse tree. For item 3 choose the lowest repitition of $R$, for that if $|vxy|>p$, a lower reoccurrence would happen, contradicting ``lowest".
\end{proof}

\begin{reference}{Eg}{pumpingcfleg} Usages of \ref{pumpingcfl}:
  \begin{enumerate}
    \item $0^k1^k2^k$ is not a CFL. Suppose it is with pumping length $p$ then we can pump $0^p1^p2^p$, which we cannot.
    \item $ww$ is not a CFL. Suppose it is with pumping length $p$ then we can pump $0^p1^p0^p1^p$, which we cannot. (Use $uv^0xy^0z$, or any other pumping choices, as long as you take care of what is pumped.)\qedhere
  \end{enumerate}
\end{reference}

Obviously $0^k1^k2^l$ and $0^l1^k2^k$ both are CFLs, thus we have a counterexample showing that the class of CFLs is not closed under intersection. By \ref{2.16} it is closed under union. So it is not closed under complementation by De Morgan's law ($\overline{\overline{A}\cup \overline{B}}=A\cap B$). Why is it closed under union but not closed under intersection? Intuitively, given two CFGs, you can guess which one to use to get the union, but there is no obvious way to use them \textit{both}. Also, given two PDAs, you can guess which of the stacks to keep, but you cannot easily simulate \textit{both} with only one.

\section*{Exercises and Problems}

\setcounter{exercise}{14}

\begin{exercise}
  Give a counterexample to show that the following construction fails to prove that the class of context-free languages is closed under star. Let \( A \) be a CFL that is generated by the CFG \( G = (V, \Sigma, R, S) \). Add the new rule \( S \rightarrow SS \) and call the resulting grammar \( G' \). This grammar is supposed to generate \( A^* \).
\end{exercise}

Let $G=(\{S\}, \{a\}, \{S\to a\}, S)$, then $L(G')$ does not contain $\varepsilon\in A^*$. Another counterexample would be $G=(\{S\},\{a,b\},\{S\to aSa|b\},S)$. Then $L(G')$ contains $abba\notin A^*$. This exercise tell us to be careful with the original grammar.

\begin{exercise}
  Show that the class of context-free languages is closed under the regular operations (\ref{regularoper}).
\end{exercise}

Say that we are given CFGs $G_1$ and $G_2$. To get $G_{\cup}$ we add rule $S\to S_1|S_2$. To get $G_{\circ}$ we add rule $S\to S_1S_2$. To get $G_{*}$ (of $G_1$) we add rule $S\to SS_1|\varepsilon$.

\begin{exercise}
  Refer to \ref{2.16} to give another proof that every regular language is context free by showing how to convert a regular expression directly to an equivalent context-free grammar.
\end{exercise}

Define a CFG $G$ according to a regular language $R$. Consider the subset $R_G$ of a regular language that can be generated by $G$. Obviously $R_G$ is closed under regular operations and contains the symbols that occur in $R$. By induction theorem we have $R_G=R$, so $R$ is a CFL.

\begin{exercise}
  (a) Let $C$ be a context-free language and $R$ be a regular language. Prove that the language $C\cap R$ is context free. (b) Use part (a) to show that the language $A = \{w| w \in \{a, b, c\}^*\ \text{and contains equal numbers of $a$'s, $b$'s, and $c$'s}\}$ is not a CFL.
\end{exercise}

(a) We can construct a PDA whose set of states is $Q=Q_{C}\times Q_{R}$, the transition function $\delta$ defined by $\delta((q_c, q_r),a,x)=\{((q_c',q_r'),\gamma)|(q_c',\gamma)\in \delta_C(q_c,a,x),q_r'=\delta_R(q_r,a)\}$ and accept states $F=F_C\times F_R$. (b) If it is, so would be $a^kb^kc^k=A\cap a^*b^*c^*$, which is not by \ref{pumpingcfl}.

\setcounter{exercise}{21}

\begin{exercise}
  Let $C=\{x\#y|x,y\in\{0,1\}^*\text{ and }x\neq y\}.$ Show that $C$ is context-free.
\end{exercise}

\textcolor{red}{to do}

\setcounter{exercise}{23}

\begin{exercise}
  Show that $E=\{a^ib^j|i\neq j \wedge 2i\neq j\}$ is a context-free language.
\end{exercise}

\textcolor{red}{to do}

\setcounter{exercise}{25}

\begin{exercise}
  Show that, if $G$ is a CFG in Chomsky normal form, then for any string $w \in L(G)$ of length $n \geq 1$, exactly $2n - 1$ steps are required for any derivation of $w$.
\end{exercise}

Each application of a rule of the form $A\to BC$ increases the length of the string by 1 (because $B$ and $C$ are never to derive $\varepsilon$), so we have $n-1$ steps here. We also need $n$ applications of terminal rules $A\to a$ to convert the variables into terminals. So $2n-1$ steps are needed as a minimum. Note also that any one more step will lead to a string different from $w$.

\begin{exercise}
  $G=(V,\Sigma,R,\langle \text{STMT}\rangle)$ is described as follows.
  \begin{align*}
    \langle \text{STMT}\rangle         & \rightarrow\langle \text{ASSIGN}\rangle|\langle \text{IF-THEN}\rangle|\langle \text{IF-THEN-ELSE}\rangle                  \\
    \langle \text{IF-THEN}\rangle      & \rightarrow \texttt{if condition then }\langle \text{STMT}\rangle                                                         \\
    \langle \text{IF-THEN-ELSE}\rangle & \rightarrow\texttt{if condition then }\langle \text{STMT}\rangle\texttt{ else }\langle \text{STMT}\rangle                 \\
    \langle \text{ASSIGN}\rangle       & \rightarrow\texttt{a:=1},                                                                                                 \\
    \Sigma                             & =\{\texttt{if,condition,then,else,a:=1}\}                                                                                 \\
    V                                  & =\{\langle\text{STMT}\rangle,\langle\text{IF-THEN}\rangle,\langle\text{IF-THEN-ELSE}\rangle,\langle\text{ASSIGN}\rangle\}
  \end{align*}
  \begin{enumerate}[label=(\alph*)]
    \item Show that $G$ is ambiguous.
    \item Give a new unambiguous grammar for the same language.\qedhere
  \end{enumerate}
\end{exercise}

\textcolor{red}{to do}

\setcounter{exercise}{31}

\begin{exercise}
  Let $\Sigma = \{1, 2, 3, 4\}$ and $C = \{ w \in \Sigma^* \mid \text{in } w$, the number of 1s equals the number of 2s, and the number of 3s equals the number of 4s$\}$. Show that $C$ is not context-free.
\end{exercise}

Suppose $C$ is with pumping length $p$. But we can not pump $1^p3^p2^p4^p$.

% TODO: What if the PDA used a queue instead of a stack?
